#!/usr/bin/env node
import fs from "fs";
import {
  createConnection,
  TextDocuments,
  ProposedFeatures,
} from "vscode-languageserver/node.js";
import { TextDocument } from "vscode-languageserver-textdocument";
import * as Build from "./src/lang-server/build.mjs";
import * as Repo from "./src/lang-server/repo.mjs";

// Create connection and document manager
const connection = createConnection(ProposedFeatures.all);
const documents = new TextDocuments(TextDocument);

// Initialize an empty repository
let repo = Repo.init(new Map())

// Initialize server capabilities
connection.onInitialize((params) => {
  /*
  params:
  {
    "processId": null,
    "rootUri": "file:///Users/manne/dev/tjs/v4/example",
    "capabilities": {
      "workspace": {
        "applyEdit": true,
        "workspaceEdit": {
          "documentChanges": true,
          "resourceOperations": [
            "create",
            "rename",
            "delete"
          ],
          "snippetEditSupport": true
        },
        "didChangeConfiguration": {
          "dynamicRegistration": true
        },
        "didChangeWatchedFiles": {
          "dynamicRegistration": true,
          "relativePatternSupport": true
        },
        "symbol": {},
        "executeCommand": {
          "dynamicRegistration": false
        },
        "workspaceFolders": true,
        "configuration": true,
        "codeLens": {
          "refreshSupport": true
        },
        "fileOperations": {
          "dynamicRegistration": false,
          "didRename": true,
          "willRename": true
        },
        "inlayHint": {
          "refreshSupport": true
        },
        "diagnostic": {}
      },
      "textDocument": {
        "synchronization": {
          "didSave": true
        },
        "completion": {
          "completionItem": {
            "snippetSupport": true,
            "insertReplaceSupport": true,
            "resolveSupport": {
              "properties": [
                "additionalTextEdits",
                "command",
                "documentation"
              ]
            },
            "insertTextModeSupport": {
              "valueSet": [
                1,
                2
              ]
            },
            "labelDetailsSupport": true
          },
          "contextSupport": true,
          "insertTextMode": 2,
          "completionList": {
            "itemDefaults": [
              "commitCharacters",
              "editRange",
              "insertTextMode",
              "insertTextFormat",
              "data"
            ]
          }
        },
        "hover": {
          "contentFormat": [
            "markdown"
          ]
        },
        "signatureHelp": {
          "signatureInformation": {
            "documentationFormat": [
              "markdown",
              "plaintext"
            ],
            "parameterInformation": {
              "labelOffsetSupport": true
            },
            "activeParameterSupport": true
          }
        },
        "documentSymbol": {
          "hierarchicalDocumentSymbolSupport": true
        },
        "formatting": {
          "dynamicRegistration": true
        },
        "rangeFormatting": {
          "dynamicRegistration": true
        },
        "onTypeFormatting": {
          "dynamicRegistration": true
        },
        "definition": {
          "linkSupport": true
        },
        "codeAction": {
          "codeActionLiteralSupport": {
            "codeActionKind": {
              "valueSet": [
                "refactor",
                "quickfix",
                "source"
              ]
            }
          },
          "dataSupport": true,
          "resolveSupport": {
            "properties": [
              "kind",
              "diagnostics",
              "isPreferred",
              "disabled",
              "edit",
              "command"
            ]
          }
        },
        "codeLens": {
          "dynamicRegistration": false
        },
        "rename": {
          "prepareSupport": true,
          "prepareSupportDefaultBehavior": 1
        },
        "publishDiagnostics": {
          "relatedInformation": true
        },
        "inlayHint": {
          "dynamicRegistration": false,
          "resolveSupport": {
            "properties": [
              "textEdits",
              "tooltip",
              "label.tooltip",
              "label.location",
              "label.command"
            ]
          }
        }
      },
      "window": {
        "workDoneProgress": true,
        "showMessage": {}
      },
      "general": {
        "positionEncodings": [
          "utf-16"
        ]
      },
      "experimental": {
        "serverStatusNotification": true,
        "localDocs": true
      }
    },
    "workspaceFolders": [
      {
        "uri": "file:///Users/manne/dev/tjs/v4/example",
        "name": ""
      }
    ],
    "clientInfo": {
      "name": "Zed",
      "version": "0.187.9"
    }
  }
  */
  // @todo: Process working dirs (or just the first one to start with). Parse and build up modules cache for all js files.
  connection.console.log("=== TJS Language Server Starting ===");
  connection.console.log(`Client: ${params.clientInfo?.name || "Unknown"}`);
  connection.console.log(`Process ID: ${params.processId}`);
  connection.console.log(`Root URI: ${params.rootUri}`);
  connection.console.log(`PARAMS: ${JSON.stringify(params, null, 2)}`);

  const workspaceFolders = params.workspaceFolders || [];
  const workspaceModulesMap = new Map();
  
  for (const folder of workspaceFolders) {
    // Convert file:// URI to local path
    const workspaceDir = folder.uri.replace('file://', '');
    connection.console.log(`Building modules for workspace: ${workspaceDir}`);
    
    try {
      const modules = Build.buildModulesFromDir(workspaceDir);
      workspaceModulesMap.set(workspaceDir, modules);
      connection.console.log(`Found ${modules.size} modules in ${workspaceDir}`);
    } catch (error) {
      connection.console.log(`Error building modules for ${workspaceDir}: ${error.message}`);
    }
  }
  
  repo = Repo.init(workspaceModulesMap);
  connection.console.log(`Initialized repo with ${workspaceModulesMap.size} workspaces`);

  return {
    capabilities: {
      textDocumentSync: {
        openClose: true,
        change: 2, // Incremental sync
      },
      // hoverProvider: true,
      // definitionProvider: true,
      // diagnosticsProvider: true
    },
  };
});

connection.onInitialized(() => {
  connection.console.log("Server initialized and ready!");
});

documents.onDidOpen((event) => {
  connection.console.log(`Document opened: ${event.document.uri}`);
});

documents.onDidClose((event) => {
  connection.console.log(`Document closed: ${event.document.uri}`);
});

connection.onShutdown(() => {
  connection.console.log("Server shutting down...");
});

const checkDocument = (text) => {};

// Handle document changes and run typechecker
documents.onDidChangeContent(async (change) => {
  /**
  params:
  {
    "document": {
      "_uri": "file:///Users/manne/dev/tjs/v4/example/index.mjs",
      "_languageId": "javascript",
      "_version": 0,
      "_content": "import { sum } from \"./math.mjs\";\n\nexport let name = \"Viktor\";\n\nexport default sumza;\n"
    }
  }
  */
  // @todo:
  //   1. Update module cache with new contents
  //   2. Run namecheck and report errors as diagnostics
  //   3. Run typechecker and report errors as diagnostics
  const document = change.document;
  const text = document.getText();

  connection.console.log("=> onDidChangeContent");
  connection.console.log(`Document URI: ${document.uri}`);
  
  // Convert file:// URI to local path
  const filePath = document.uri.replace('file://', '');
  const foundModule = Repo.findModule(repo, filePath);
  
  if (foundModule) {
    connection.console.log(`Found module: ${foundModule.absoluteFilePath}`);
    // TODO: Update module with new content using Repo.updateModule
    const updatedModule = Repo.updateModule(repo, filePath, text);
    if (updatedModule) {
      connection.console.log(`Updated module successfully`);
    }
  } else {
    connection.console.log(`Module not found for: ${filePath}`);
  }
  
  connection.console.log("END onDidChangeContent");

  // try {
  //     // Use your typechecker here
  //     const result = await typeChecker.check(text, document.uri);

  //     // Convert your typechecker errors to LSP diagnostics
  //     const diagnostics = result.errors.map(error => ({
  //         severity: error.severity === 'error' ? 1 : 2, // Error or Warning
  //         range: {
  //             start: { line: error.line - 1, character: error.column - 1 },
  //             end: { line: error.endLine - 1, character: error.endColumn - 1 }
  //         },
  //         message: error.message,
  //         source: 'my-typechecker'
  //     }));

  //     connection.sendDiagnostics({ uri: document.uri, diagnostics });
  // } catch (error) {
  //     console.error('Typechecker error:', error);
  // }
});

// Provide hover information
// connection.onHover(async (params) => {
//   const document = documents.get(params.textDocument.uri);
//   if (!document) return null;

//   const position = params.position;
//   const text = document.getText();

//   const hoverInfo = {
//     type: `Hello World!`,
//     documentation: "Greetings from TJS language server :)",
//   };

//   if (hoverInfo) {
//     return {
//       contents: {
//         kind: "markdown",
//         value: `**${hoverInfo.type}**\n\n${hoverInfo.documentation || ""}`,
//       },
//     };
//   }

//   return null;
// });

// Connect documents to the connection
documents.listen(connection);
connection.listen();
